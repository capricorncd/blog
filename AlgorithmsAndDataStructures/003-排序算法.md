# 排序算法

所谓**排序**，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。

## 分类

**排序(Sorting)** 是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个关键字有序的序列。

##### # 稳定度（稳定性）

一个排序算法是稳定的，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。

当相等的元素是无法分辨的，比如像是整数，稳定度并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。

（4,1）（3,1）（3,7）（5,6）在这个状况下，有可能产生两种不同的结果，一个是依照相等的键值维持相对的次序，而另外一个则没有：

（3,1）（3,7）（4,1）（5,6） （维持次序）

（3,7）（3,1）（4,1）（5,6） （次序被改变）

不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。作这件事情的一个方式是人工扩充键值的比较，如此在其他方面相同键值的两个对象间之比较，就会被决定使用在原先数据次序中的条目，当作一个同分决赛。然而，要记住这种次序通常牵涉到额外的空间负担。

##### # 在计算机科学所使用的排序算法通常被分类为：

(a) 计算的复杂度（最差、平均、和最好性能），依据列表(list)的大小(n)。

一般而言，好的性能是 O(nlogn)，且坏的性能是 O(n^2)。对于一个排序理想的性能是 O(n)。

而仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要 O(nlogn)。

(b) 存储器使用量（空间复杂度）（以及其他电脑资源的使用）

(c) 稳定度：稳定的排序算法会依照相等的关键（换言之就是值）维持纪录的相对次序。

(d) 一般的方法：插入、交换、选择、合并等等。交换排序包含冒泡排序和快速排序。插入排序包含希尔排序，选择排序包括堆排序等。

## 算法列表

#### # 稳定的

* 冒泡排序（bubble sort） — O(n^2）

* 鸡尾酒排序(Cocktail sort，双向的冒泡排序) — O(n^2）

* 插入排序（insertion sort）— O(n^2)

* 桶排序（bucket sort）— O(n); 需要 O(k) 额外空间

* 计数排序(counting sort) — O(n+k); 需要 O(n+k) 额外空间

* 合并排序（merge sort）— O(nlog n); 需要 O(n) 额外空间

* 原地合并排序— O(n^2)

* 二叉排序树排序 （Binary tree sort） — O(nlog n)期望时间； O(n^2)最坏时间； 需要 O(n) 额外空间

* 鸽巢排序(Pigeonhole sort) — O(n+k); 需要 O(k) 额外空间

* 基数排序（radix sort）— O(n·k); 需要 O(n) 额外空间

* Gnome 排序— O(n^2)

* 图书馆排序— O(nlog n) with high probability，需要 （1+ε)n额外空间

#### # 不稳定的

* 选择排序（selection sort）— O(n^2)

* 希尔排序（shell sort）— O(nlog n) 如果使用最佳的现在版本

* 组合排序— O(nlog n)

* 堆排序（heapsort）— O(nlog n)

* 平滑排序— O(nlog n)

* 快速排序（quicksort）— O(nlog n) 期望时间，O(n^2) 最坏情况； 对于大的、乱数列表一般相信是最快的已知排序

* Introsort— O(nlog n)

* 耐心排序— O(nlog n+ k) 最坏情况时间，需要 额外的 O(n+ k) 空间，也需要找到最长的递增子串行（longest increasing subsequence）

#### # 不实用的

* Bogo排序— O(n× n!) 期望时间，无穷的最坏情况。

* Stupid sort— O(n^3); 递归版本需要 O(n^2) 额外存储器

* 珠排序（Bead sort） — O(n) or O（√n)，但需要特别的硬件

* Pancake sorting— O(n)，但需要特别的硬件

* stooge sort——O（n^2.7）很漂亮但是很耗时

## 排序算法

排序的算法有很多，对空间的要求及其时间效率也不尽相同。下面列出了一些常见的排序算法。这里面插入排序和冒泡排序又被称作简单排序，他们对空间的要求不高，但是时间效率却不稳定；而后面三种排序相对于简单排序对空间的要求稍高一点，但时间效率却能稳定在很高的水平。基数排序是针对关键字在一个较小范围内的排序算法。

* 插入排序

* 冒泡排序

* 选择排序

* 快速排序

* 堆排序

* 归并排序

* 基数排序

* 希尔排序

#### # 插入排序

插入排序是这样实现的：

1、首先新建一个空列表，用于保存已排序的有序数列（我们称之为"有序列表"）。

2、从原数列中取出一个数，将其插入"有序列表"中，使其仍旧保持有序状态。

3、重复2号步骤，直至原数列为空。

插入排序的平均时间复杂度为平方级的，效率不高，但是容易实现。它借助了"逐步扩大成果"的思想，使有序列表的长度逐渐增加，直至其长度等于原列表的长度。

插入排序的基本思想是在遍历数组的过程中，假设在序号 i 之前的元素即 [0..i-1] 都已经排好序，本趟需要找到 i 对应的元素 x 的正确位置 k ，并且在寻找这个位置 k 的过程中逐个将比较过的元素往后移一位，为元素 x “腾位置”，最后将 k 对应的元素值赋为 x ，一般情况下，插入排序的时间复杂度和空间复杂度分别为 O(n2 ) 和 O(1)。

#### # 冒泡排序

冒泡排序是这样实现的：

1、从列表的第一个数字到倒数第二个数字，逐个检查：若某一位上的数字大于他的下一位，则将它与它的下一位交换。

2、重复1号步骤，直至再也不能交换。

冒泡排序的平均时间复杂度与插入排序相同，也是平方级的，但冒泡排序是原地排序的，也就是说它不需要额外的存储空间。

#### # 选择排序

选择排序是这样实现的：

1、设数组内存放了n个待排数字，数组下标从1开始，到n结束。

2、初始化i=1

3、从数组的第i个元素开始到第n个元素，寻找最小的元素。

4、将上一步找到的最小元素和第i位元素交换。

5、i++,直到i=n－1算法结束，否则回到第3步

选择排序的平均时间复杂度也是O(n^2)的。

举例：

564

> 比如说这个，我想让它从小到大排序，怎么做呢？

> 第一步：从第一位开始找最小的元素，564中4最小，与第一位交换。结果为465

> 第二步：从第二位开始找最小的元素，465中5最小，与第二位交换。结果为456

> 第三步：i=2，n=3，此时i=n-1，算法结束

完成

#### # 快速排序

现在开始，我们要接触高效排序算法了。实践证明，快速排序是所有排序算法中最高效的一种。它采用了分治的思想：先保证列表的前半部分都小于后半部分，然后分别对前半部分和后半部分排序，这样整个列表就有序了。这是一种先进的思想，也是它高效的原因。因为在排序算法中，算法的高效与否与列表中数字间的比较次数有直接的关系，而"保证列表的前半部分都小于后半部分"就使得前半部分的任何一个数从此以后都不再跟后半部分的数进行比较了，大大减少了数字间不必要的比较。但查找数据得另当别论了。

#### # 时间复杂度

平均时间复杂度

* 插入排序 O(n^2）

* 冒泡排序 O(n^2）

* 选择排序 O(n^2）

* 快速排序 O(n log n)

* 堆排序 O(n log n)

* 归并排序 O(n log n)

* 基数排序 O(n)

* 希尔排序 O(n^1.25）
